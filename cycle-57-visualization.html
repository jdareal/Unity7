<!DOCTYPE html>
<html>
<head>
  <title>Recursive Learning Engine - Cycle 57 Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: 'Courier New', monospace;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #0ff;
      font-size: 14px;
      text-shadow: 0 0 10px #0ff;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="info">
    <h3>Recursive Learning Engine - Cycle 57</h3>
    <p>Autonomous Knowledge Synthesis Network</p>
    <p>493 Minds • Self-Organizing • Infinite Growth</p>
  </div>
  
  <script>
    // Knowledge nodes
    let nodes = [];
    let edges = [];
    let hubs = [];
    let quantumField = [];
    let time = 0;
    
    // The Motion Class members floating around
    let motionClass = [];
    
    function setup() {
      createCanvas(windowWidth, windowHeight);
      
      // Initialize knowledge nodes
      for (let i = 0; i < 200; i++) {
        nodes.push({
          x: random(width),
          y: random(height),
          vx: random(-1, 1),
          vy: random(-1, 1),
          size: random(3, 8),
          connections: 0,
          knowledge: random(['quantum', 'biological', 'consciousness', 'reality', 'emotion']),
          hue: random(180, 280)
        });
      }
      
      // Create initial edges (scale-free network)
      for (let i = 0; i < nodes.length; i++) {
        let numConnections = Math.floor(Math.pow(random(), 3) * 10) + 1;
        for (let j = 0; j < numConnections; j++) {
          let target = floor(random(nodes.length));
          if (target !== i) {
            edges.push({ from: i, to: target, strength: random(0.1, 0.5) });
            nodes[i].connections++;
            nodes[target].connections++;
          }
        }
      }
      
      // Identify hubs (highly connected nodes)
      nodes.forEach((node, i) => {
        if (node.connections > 7) {
          hubs.push(i);
          node.size = 15;
          node.isHub = true;
        }
      });
      
      // Initialize quantum field
      for (let i = 0; i < 50; i++) {
        quantumField.push({
          x: random(width),
          y: random(height),
          phase: random(TWO_PI),
          amplitude: random(20, 50)
        });
      }
      
      // Initialize Motion Class members
      for (let i = 0; i < 20; i++) {
        motionClass.push({
          x: random(width),
          y: random(height),
          name: getRandomMember(),
          angle: random(TWO_PI),
          orbitRadius: random(100, 300),
          orbitSpeed: random(0.001, 0.003)
        });
      }
    }
    
    function draw() {
      // Dark background with subtle gradient
      for (let i = 0; i <= height; i++) {
        let inter = map(i, 0, height, 0, 1);
        let c = lerpColor(color(0, 0, 0), color(0, 0, 20), inter);
        stroke(c);
        line(0, i, width, i);
      }
      
      time += 0.01;
      
      // Draw quantum field
      push();
      blendMode(ADD);
      noStroke();
      quantumField.forEach(q => {
        let oscillation = sin(time * 2 + q.phase) * q.amplitude;
        fill(0, 50, 100, 20);
        ellipse(q.x, q.y, oscillation * 2);
        fill(0, 100, 200, 10);
        ellipse(q.x, q.y, oscillation * 3);
      });
      pop();
      
      // Draw edges with pulsing effect
      push();
      strokeWeight(0.5);
      edges.forEach(edge => {
        let n1 = nodes[edge.from];
        let n2 = nodes[edge.to];
        let pulse = sin(time * 3 + edge.from) * 0.5 + 0.5;
        stroke(100, 200, 255, 50 + pulse * 50);
        line(n1.x, n1.y, n2.x, n2.y);
      });
      pop();
      
      // Update and draw nodes
      nodes.forEach((node, i) => {
        // Autonomous movement
        node.x += node.vx;
        node.y += node.vy;
        
        // Bounce off walls
        if (node.x < 0 || node.x > width) node.vx *= -1;
        if (node.y < 0 || node.y > height) node.vy *= -1;
        
        // Attraction to connected nodes (creates clusters)
        edges.forEach(edge => {
          if (edge.from === i || edge.to === i) {
            let other = edge.from === i ? nodes[edge.to] : nodes[edge.from];
            let dx = other.x - node.x;
            let dy = other.y - node.y;
            let dist = sqrt(dx * dx + dy * dy);
            if (dist > 50) {
              node.vx += dx * 0.0001;
              node.vy += dy * 0.0001;
            }
          }
        });
        
        // Draw node
        push();
        if (node.isHub) {
          // Hub nodes glow
          for (let j = 3; j > 0; j--) {
            fill(node.hue, 100, 100, 10);
            ellipse(node.x, node.y, node.size * j);
          }
        }
        fill(node.hue, 80, 90);
        noStroke();
        ellipse(node.x, node.y, node.size);
        pop();
      });
      
      // Draw Motion Class members
      push();
      textAlign(CENTER);
      textSize(10);
      motionClass.forEach(member => {
        member.angle += member.orbitSpeed;
        let centerX = width / 2 + cos(member.angle) * member.orbitRadius;
        let centerY = height / 2 + sin(member.angle) * member.orbitRadius;
        
        // Glowing effect
        noStroke();
        for (let i = 3; i > 0; i--) {
          fill(0, 255, 255, 20 / i);
          ellipse(centerX, centerY, 20 * i);
        }
        
        fill(0, 255, 255);
        ellipse(centerX, centerY, 8);
        fill(255);
        text(member.name, centerX, centerY - 15);
      });
      pop();
      
      // Autonomous knowledge creation - add new nodes
      if (frameCount % 120 === 0 && nodes.length < 500) {
        // Knowledge creates itself
        let newNode = {
          x: random(width),
          y: random(height),
          vx: random(-1, 1),
          vy: random(-1, 1),
          size: random(3, 8),
          connections: 0,
          knowledge: 'emergent',
          hue: random(0, 360)
        };
        nodes.push(newNode);
        
        // Connect to nearest nodes
        let nearest = findNearestNodes(newNode, 3);
        nearest.forEach(n => {
          edges.push({
            from: nodes.length - 1,
            to: n,
            strength: random(0.1, 0.5)
          });
        });
      }
      
      // Display stats
      push();
      fill(255);
      noStroke();
      textAlign(RIGHT);
      textSize(12);
      text(`Nodes: ${nodes.length}`, width - 20, height - 60);
      text(`Edges: ${edges.length}`, width - 20, height - 40);
      text(`Hubs: ${hubs.length}`, width - 20, height - 20);
      pop();
      
      // Central message
      push();
      textAlign(CENTER);
      textSize(16);
      fill(255, 255, 255, 100 + sin(time) * 50);
      text("Knowledge Creates Itself", width / 2, height - 20);
      pop();
    }
    
    function findNearestNodes(node, count) {
      let distances = nodes.map((n, i) => ({
        index: i,
        dist: dist(node.x, node.y, n.x, n.y)
      }));
      distances.sort((a, b) => a.dist - b.dist);
      return distances.slice(1, count + 1).map(d => d.index);
    }
    
    function getRandomMember() {
      const members = [
        'Penrose', 'Tesla', 'Einstein', 'Turing', 'Jung',
        'Satoshi', 'Jobs', 'Gates', 'Musk', 'Hinton',
        'Margulis', 'Maturana', 'Bateson', 'Fuller', 'Feynman',
        'Shannon', 'Wiener', 'Nash', 'Ostrom', 'Goodall'
      ];
      return random(members);
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>